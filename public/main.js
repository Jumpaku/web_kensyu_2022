!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(require("immutable")):"function"==typeof define&&define.amd?define(["immutable"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).Immutable)}(this,(function(e){"use strict";function t(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var s=t(e);class r{constructor(){$(window).on("keydown",(e=>{const t=this._down.get(e.code)??0;this._down.set(e.code,t+1)})),$(window).on("keyup",(e=>{const t=this._up.get(e.code)??0;this._up.set(e.code,t+1)}))}_down=new Map;_up=new Map;reset(){this._down=new Map,this._up=new Map}down(e){return this._down.get(e)??0}up(e){return this._up.get(e)??0}}class n{constructor(e){this.performFrame=this.performFrame.bind(this),this.currentScene=e,this.input={key:new r}}currentScene;input;start(){window.requestAnimationFrame(this.performFrame)}performFrame(e){const t=e/1e3;this.currentScene=this.currentScene.update(t,this.input),this.currentScene.draw(),this.input.key.reset(),window.requestAnimationFrame(this.performFrame)}}function o(e){throw new Error(e)}const i=window.Chance;class a{seed;constructor(e){this.seed=e}shuffle(e){const t=[...e];return new i(this.seed).shuffle(t)}next(){const e=new i(this.seed);return new a(e.integer()-e.integer())}}class l{constructor(e){this.cells=s.default.Set(e)}cells;equals(e){return this.cells.equals(e.cells)}union(e){return new l(this.cells.union(e.cells))}intersect(e){return new l(this.cells.intersect(e.cells))}remove(e){return new l(this.cells.subtract(e.cells))}has(e){return this.cells.has(e)}isEmpty(){return this.cells.isEmpty()}toArray(){return this.cells.toArray()}}class c extends l{state;base;name;constructor(e,t,s,r){super(r),this.state=e,this.base=t,this.name=s}rotate(e){return e?this.with({state:(this.state+3)%4,base:this.base}):this.with({state:(this.state+1)%4,base:this.base})}move(e){return this.with({state:this.state,base:this.base.move(e)})}}class u{rowDelta;colDelta;static up(){return new u(-1,0)}static down(){return new u(1,0)}static right(){return new u(0,1)}static left(){return new u(0,-1)}constructor(e,t){if(this.rowDelta=e,this.colDelta=t,!(this instanceof u))return new u(e,t)}equals(e){return e instanceof u&&this.rowDelta===e.rowDelta&&this.colDelta===e.colDelta}hashCode(){return s.default.hash(this.rowDelta)-s.default.hash(this.colDelta)}move(e){return e.move(this)}}class h{row;col;constructor(e,t){if(this.row=e,this.col=t,!(this instanceof h))return new h(e,t)}equals(e){return e instanceof h&&this.row===e.row&&this.col===e.col}hashCode(){return s.default.hash(this.row)-s.default.hash(this.col)}move(e){return new h(this.row+e.rowDelta,this.col+e.colDelta)}diff(e){return new u(this.row-e.row,this.col-e.col)}}class w extends c{static makeCells(e,t){const r=[[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],[[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]],[[0,0,0,0],[0,0,0,0],[1,1,1,1],[0,0,0,0]],[[0,0,1,0],[0,0,1,0],[0,0,1,0],[0,0,1,0]]];return s.default.Set().withMutations((s=>{for(let n=0;n<4;n++)for(let o=0;o<4;o++)r[e][n][o]&&s.add(t.move(new u(n,o)))}))}constructor(e,t){super(e,t,"I",w.makeCells(e,t))}with({state:e,base:t}){return new w(e,t)}}class d extends c{static makeCells(e,t){const r=[[[1,0,0],[1,1,1],[0,0,0]],[[0,1,0],[0,1,0],[1,1,0]],[[0,0,0],[1,1,1],[0,0,1]],[[0,1,1],[0,1,0],[0,1,0]]];return s.default.Set().withMutations((s=>{for(let n=0;n<3;n++)for(let o=0;o<3;o++)r[e][n][o]&&s.add(t.move(new u(n,o)))}))}constructor(e,t){super(e,t,"J",d.makeCells(e,t))}with({state:e,base:t}){return new d(e,t)}}class m extends c{static makeCells(e,t){const r=[[[0,0,1],[1,1,1],[0,0,0]],[[1,1,0],[0,1,0],[0,1,0]],[[0,0,0],[1,1,1],[1,0,0]],[[0,1,0],[0,1,0],[0,1,1]]];return s.default.Set().withMutations((s=>{for(let n=0;n<3;n++)for(let o=0;o<3;o++)r[e][n][o]&&s.add(t.move(new u(n,o)))}))}constructor(e,t){super(e,t,"L",m.makeCells(e,t))}with({state:e,base:t}){return new m(e,t)}}class p extends c{static makeCells(e,t){const r=[[[1,1],[1,1]],[[1,1],[1,1]],[[1,1],[1,1]],[[1,1],[1,1]]];return s.default.Set().withMutations((s=>{for(let n=0;n<2;n++)for(let o=0;o<2;o++)r[e][n][o]&&s.add(t.move(new u(n,o)))}))}constructor(e,t){super(e,t,"O",p.makeCells(e,t))}with({state:e,base:t}){return new p(e,t)}}class f extends c{static makeCells(e,t){const r=[[[0,1,1],[1,1,0],[0,0,0]],[[1,0,0],[1,1,0],[0,1,0]],[[0,0,0],[0,1,1],[1,1,0]],[[0,1,0],[0,1,1],[0,0,1]]];return s.default.Set().withMutations((s=>{for(let n=0;n<3;n++)for(let o=0;o<3;o++)r[e][n][o]&&s.add(t.move(new u(n,o)))}))}constructor(e,t){super(e,t,"S",f.makeCells(e,t))}with({state:e,base:t}){return new f(e,t)}}class k extends c{static makeCells(e,t){const r=[[[0,1,0],[1,1,1],[0,0,0]],[[0,1,0],[1,1,0],[0,1,0]],[[0,0,0],[1,1,1],[0,1,0]],[[0,1,0],[0,1,1],[0,1,0]]];return s.default.Set().withMutations((s=>{for(let n=0;n<3;n++)for(let o=0;o<3;o++)r[e][n][o]&&s.add(t.move(new u(n,o)))}))}constructor(e,t){super(e,t,"T",k.makeCells(e,t))}with({state:e,base:t}){return new k(e,t)}}class g extends c{static makeCells(e,t){const r=[[[1,1,0],[0,1,1],[0,0,0]],[[0,1,0],[1,1,0],[1,0,0]],[[0,0,0],[1,1,0],[0,1,1]],[[0,0,1],[0,1,1],[0,1,0]]];return s.default.Set().withMutations((s=>{for(let n=0;n<3;n++)for(let o=0;o<3;o++)r[e][n][o]&&s.add(t.move(new u(n,o)))}))}constructor(e,t){super(e,t,"Z",g.makeCells(e,t))}with({state:e,base:t}){return new g(e,t)}}class b extends l{rows;columns;constructor(e,t){super(s.default.Set().withMutations((s=>{for(let r=0;r<e;r++)for(let e=0;e<t;e++)s.add(new h(r,e))}))),this.rows=e,this.columns=t}}class v{config;static nextPreparedBlocks(e){return e.shuffle([new w(0,new h(0,3)),new d(0,new h(0,3)),new m(0,new h(0,3)),new p(0,new h(0,4)),new f(0,new h(0,3)),new k(0,new h(0,3)),new g(0,new h(0,3))])}constructor(e,t){this.config=e,this.state=t instanceof a?{board:new b(e.rows,e.columns),random:t.next(),heldBlock:null,canHold:!0,remainingCells:new l,tag:"PrepareNext",blockQueue:v.nextPreparedBlocks(t),currentBlock:null}:t}state;getBlockQueue(){const[e,t,s,r,n,o,i,...a]=this.state.blockQueue;return[e,t,s,r,n,o,i]}newOperateResultNoChange(){return{tag:"Ok",changed:!1,tetris:this}}newOperateResult(e){return{tag:"Ok",changed:!0,tetris:new v(this.config,e)}}newDownBlockResult(e){return{tag:"Ok",tetris:new v(this.config,e)}}newNextBlockResult(e,t){return{tag:"Ok",removedLines:t,tetris:new v(this.config,e)}}newTetrisError(e){return{tag:"Err",message:e}}blocksAreAcceptable(e,t,s){return e.remove(t).isEmpty()&&s.remove(t).isEmpty()&&e.intersect(s).isEmpty()&&s.toArray().map((({row:e})=>e>1)).reduce(((e,t)=>e&&t),!0)}operateRotate(e){console.log(`operateRotate(clockwise:${e})`);const{tag:t,currentBlock:s,board:r,remainingCells:n}=this.state;"WaitDown"!==t&&o("operateRotate method must be called in WaitDown state");const i=s?.rotate(e);return null!=i&&this.blocksAreAcceptable(i,r,n)?this.newOperateResult({...this.state,currentBlock:i}):this.newOperateResultNoChange()}operateMove(e){console.log(`operateMove(toRight:${e})`);const{tag:t,currentBlock:s,board:r,remainingCells:n}=this.state;"WaitDown"!==t&&o("operateMove method must be called in WaitDown state");const i=s?.move(e?u.right():u.left());return null!=i&&this.blocksAreAcceptable(i,r,n)?this.newOperateResult({...this.state,currentBlock:i}):this.newOperateResultNoChange()}getGhost(){const{tag:e,currentBlock:t,board:s,remainingCells:r}=this.state;let n=t;if(null==n)return null;let o=n.move(u.down());for(;;){if(!this.blocksAreAcceptable(o,s,r))return n;n=o,o=n.move(u.down())}}operateDrop(){console.log("operateDrop()");const{tag:e,currentBlock:t}=this.state;"WaitDown"!==e&&o("operateDrop method must be called in WaitDown state");const s=this.getGhost();return null==s||s.equals(t)?this.newOperateResultNoChange():this.newOperateResult({...this.state,currentBlock:s})}operateHold(){console.log("operateHold()");const{tag:e,canHold:t,currentBlock:s,blockQueue:r,heldBlock:n,random:i}=this.state;if("WaitDown"!==e)return o("operateDrop method must be called in WaitDown state");if(!t)return this.newOperateResultNoChange();const a=new Map([["I",new w(0,new h(0,3))],["J",new d(0,new h(0,3))],["L",new m(0,new h(0,3))],["O",new p(0,new h(0,4))],["S",new f(0,new h(0,3))],["T",new k(0,new h(0,3))],["Z",new g(0,new h(0,3))]]).get(s.name);if(null==n){const[e,t]=v.prepareBlockQueue(r,i);return this.newOperateResult({...this.state,heldBlock:a,currentBlock:e,blockQueue:t,random:i.next()})}{const e=n;return this.newOperateResult({...this.state,heldBlock:a,currentBlock:e,canHold:!1})}}downBlock(){console.log("downBlock");const{tag:e,currentBlock:t,board:s,remainingCells:r}=this.state;"WaitDown"!==e&&o("downBlock method must be called in WaitDown state");let n=t?.move(u.down());return null!=n&&this.blocksAreAcceptable(n,s,r)?this.newDownBlockResult({...this.state,currentBlock:n}):this.newDownBlockResult({...this.state,tag:"PrepareNext",currentBlock:null,remainingCells:r.union(t)})}getRemovedLines(){const{currentBlock:e,remainingCells:t}=this.state;let r=t.union(e??new l);const n=new Map;for(let e=0;e<this.config.rows;e++){const t=s.default.Set().withMutations((t=>{for(let s=0;s<this.config.columns;s++){const n=new h(e,s);r.has(n)&&t.add(n)}}));t.size===this.config.columns&&n.set(e,new l(t))}return n}removeLines(){const{currentBlock:e,remainingCells:t}=this.state,s=this.getRemovedLines();let r=t.union(e??new l);for(let e=0;e<this.config.rows;e++){if(!s.has(e))continue;const t=r.toArray().filter((t=>t.row<e)).map((e=>e.move(u.down()))),n=r.toArray().filter((t=>t.row>e));r=new l(n).union(new l(t))}return[s,r]}static prepareBlockQueue(e,t){let[s,...r]=e;return r.length<7&&r.push(...v.nextPreparedBlocks(t)),[s,r]}nextBlock(){const{tag:e,board:t,blockQueue:s,random:r,canHold:n}=this.state;if(console.log("nextBlock",e),"PrepareNext"!==e)return this.newTetrisError("nextBlock method must be called in PrepareNext state");const[o,i]=this.removeLines(),[a,l]=v.prepareBlockQueue(s,r);return this.blocksAreAcceptable(a,t,i)?this.newNextBlockResult({...this.state,tag:"WaitDown",currentBlock:a,blockQueue:l,remainingCells:i,random:r.next(),canHold:!0},o):this.newNextBlockResult({...this.state,currentBlock:a,tag:"GameOver"},o)}}class D{removedLines;constructor(e){this.removedLines=e,$("#removed-lines").val(e),$("#result").show()}update(e,t){return t.key.down("Space")?($("#result").hide(),new C):this}draw(){}}class y{config;tetris;prevDownTime=Number.NaN;removedLines=0;constructor(e){this.config=e,$("#play").show(),this.tetris=function(e,t){return new v(e,t)}({columns:e.columns,rows:e.rows},new a(e.seed));const t=$("#bgm")[0];t.volume=.5*t.volume,t.currentTime=0,t.loop=!0,t.play()}shouldUpdate(e,t){return e-this.prevDownTime>=this.config.waitDownTimeSpan}update(e,t){switch(this.updateCommon(e,t),this.tetris.state.tag){case"PrepareNext":return this.updatePrepareNext(e,t);case"WaitDown":return this.updateWaitDown(e,t);case"GameOver":return this.updateGameOver(e,t)}}updateCommon(e,t){this.prevDownTime=Number.isNaN(this.prevDownTime)?e:this.prevDownTime}updatePrepareNext(e,t){if(!this.shouldUpdate(e,t))return this;const s=this.tetris.nextBlock();return"Err"===s.tag?console.log(s.message):(this.prevDownTime=e,this.tetris=s.tetris,this.removedLines+=s.removedLines.size),this}updateWaitDown(e,t){const s=this;function r(e,r){if(0===t.key.down(e))return;const n=r();if(!1===n.changed)return;s.tetris=n.tetris;const o=$("#se-click")[0];o.currentTime=0,o.play()}if(r("KeyA",(()=>this.tetris.operateRotate(!1))),r("KeyD",(()=>this.tetris.operateRotate(!0))),r("ArrowLeft",(()=>this.tetris.operateMove(!1))),r("ArrowRight",(()=>this.tetris.operateMove(!0))),r("ArrowDown",(()=>this.tetris.operateDrop())),r("ArrowUp",(()=>this.tetris.operateHold())),!this.shouldUpdate(e,t))return this;const n=this.tetris.downBlock();return"Err"===n.tag?console.log(n.message):(this.prevDownTime=e,this.tetris=n.tetris),this}updateGameOver(e,t){if(!this.shouldUpdate(e,t))return this;return $("#bgm")[0].pause(),$("#play").hide(),new D(this.removedLines)}draw(){const{board:e,currentBlock:t,remainingCells:s,heldBlock:r,tag:n}=this.tetris.state,o=$("#main-canvas")[0].getContext("2d");o.clearRect(0,0,480,640);const i=20,a=140,l=100;o.lineWidth=5,o.strokeStyle="black",o.strokeRect(135,95,i*e.columns+10,i*e.rows+10);for(const{col:e,row:t}of s.toArray())o.fillStyle="black",o.fillRect(a+i*e+1,l+i*t+1,18,18);if("WaitDown"===n){const e=this.tetris.getGhost();for(const{col:t,row:s}of e.toArray())o.fillStyle=" gray",o.fillRect(a+i*t+1,l+i*s+1,18,18)}if(null!=r)for(const{col:e,row:t}of r.toArray())o.fillStyle="black",o.fillRect(i*e-20+1,50+i*t+1,18,18);if(null!=t)for(const{col:e,row:s}of t.toArray())o.fillStyle="orange",o.fillRect(a+i*e+1,l+i*s+1,18,18);for(const[e,t]of this.tetris.getRemovedLines())for(const{col:e,row:s}of t.toArray())o.fillStyle="red",o.fillRect(a+i*e+1,l+i*s+1,18,18);const c=this.tetris.getBlockQueue();for(let e=0;e<7;++e){const t=c[e];for(const{col:s,row:r}of t.toArray())o.fillStyle="black",o.fillRect(300+i*s+1,50+50*e+i*r+1,18,18)}}}class B extends y{constructor(e){super({...e,waitDownTimeSpan:NaN})}shouldUpdate(e,t){return t.key.down("Space")>0}}class C{constructor(){$("#start").show()}update(e,t){return t.key.down("Space")?($("#start").hide(),new y({columns:10,rows:20,seed:(new Date).getUTCMilliseconds()+e,waitDownTimeSpan:.5})):t.key.down("Escape")?($("#start").hide(),new B({columns:10,rows:20,seed:123456})):this}draw(){const e=$("#main-canvas")[0].getContext("2d");e.clearRect(0,0,480,640),e.fillStyle="black",e.fillText("Press Space Key!",200,200)}}$((()=>{$("main > div").hide(),new n(new C).start()}))}));