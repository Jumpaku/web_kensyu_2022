!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(require("immutable")):"function"==typeof define&&define.amd?define(["immutable"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).Immutable)}(this,(function(t){"use strict";function e(t){return t&&"object"==typeof t&&"default"in t?t:{default:t}}var s=e(t);class n{constructor(){$(window).on("keydown",(t=>{const e=this._down.get(t.code)??0;this._down.set(t.code,e+1)})),$(window).on("keyup",(t=>{const e=this._up.get(t.code)??0;this._up.set(t.code,e+1)}))}_down=new Map;_up=new Map;reset(){this._down=new Map,this._up=new Map}down(t){return this._down.get(t)??0}up(t){return this._up.get(t)??0}}class r{constructor(t){this.performFrame=this.performFrame.bind(this),this.currentScene=t,this.input={key:new n}}currentScene;input;start(){window.requestAnimationFrame(this.performFrame)}performFrame(t){const e=t/1e3;this.currentScene=this.currentScene.update(e,this.input),this.currentScene.draw(),this.input.key.reset(),window.requestAnimationFrame(this.performFrame)}}function o(t){throw new Error(t)}const i=window.Chance;class a{seed;constructor(t){this.seed=t}shuffle(t){const e=[...t];return new i(this.seed).shuffle(e)}next(){const t=new i(this.seed);return new a(t.integer()-t.integer())}}class l{constructor(t){this.cells=s.default.Set(t)}cells;equals(t){return this.cells.equals(t.cells)}union(t){return new l(this.cells.union(t.cells))}intersect(t){return new l(this.cells.intersect(t.cells))}remove(t){return new l(this.cells.subtract(t.cells))}has(t){return this.cells.has(t)}isEmpty(){return this.cells.isEmpty()}toArray(){return this.cells.toArray()}}class c extends l{state;base;name;constructor(t,e,s,n){super(n),this.state=t,this.base=e,this.name=s}rotate(t){return t?this.with({state:(this.state+3)%4,base:this.base}):this.with({state:(this.state+1)%4,base:this.base})}move(t){return this.with({state:this.state,base:this.base.move(t)})}}class u{rowDelta;colDelta;static up(){return new u(-1,0)}static down(){return new u(1,0)}static right(){return new u(0,1)}static left(){return new u(0,-1)}constructor(t,e){if(this.rowDelta=t,this.colDelta=e,!(this instanceof u))return new u(t,e)}equals(t){return t instanceof u&&this.rowDelta===t.rowDelta&&this.colDelta===t.colDelta}hashCode(){return s.default.hash(this.rowDelta)-s.default.hash(this.colDelta)}move(t){return t.move(this)}}class h{row;col;constructor(t,e){if(this.row=t,this.col=e,!(this instanceof h))return new h(t,e)}equals(t){return t instanceof h&&this.row===t.row&&this.col===t.col}hashCode(){return s.default.hash(this.row)-s.default.hash(this.col)}move(t){return new h(this.row+t.rowDelta,this.col+t.colDelta)}diff(t){return new u(this.row-t.row,this.col-t.col)}}class w extends c{static makeCells(t,e){const n=[[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],[[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]],[[0,0,0,0],[0,0,0,0],[1,1,1,1],[0,0,0,0]],[[0,0,1,0],[0,0,1,0],[0,0,1,0],[0,0,1,0]]];return s.default.Set().withMutations((s=>{for(let r=0;r<4;r++)for(let o=0;o<4;o++)n[t][r][o]&&s.add(e.move(new u(r,o)))}))}constructor(t,e){super(t,e,"I",w.makeCells(t,e))}with({state:t,base:e}){return new w(t,e)}}class d extends c{static makeCells(t,e){const n=[[[1,0,0],[1,1,1],[0,0,0]],[[0,1,0],[0,1,0],[1,1,0]],[[0,0,0],[1,1,1],[0,0,1]],[[0,1,1],[0,1,0],[0,1,0]]];return s.default.Set().withMutations((s=>{for(let r=0;r<3;r++)for(let o=0;o<3;o++)n[t][r][o]&&s.add(e.move(new u(r,o)))}))}constructor(t,e){super(t,e,"J",d.makeCells(t,e))}with({state:t,base:e}){return new d(t,e)}}class m extends c{static makeCells(t,e){const n=[[[0,0,1],[1,1,1],[0,0,0]],[[1,1,0],[0,1,0],[0,1,0]],[[0,0,0],[1,1,1],[1,0,0]],[[0,1,0],[0,1,0],[0,1,1]]];return s.default.Set().withMutations((s=>{for(let r=0;r<3;r++)for(let o=0;o<3;o++)n[t][r][o]&&s.add(e.move(new u(r,o)))}))}constructor(t,e){super(t,e,"L",m.makeCells(t,e))}with({state:t,base:e}){return new m(t,e)}}class f extends c{static makeCells(t,e){const n=[[[1,1],[1,1]],[[1,1],[1,1]],[[1,1],[1,1]],[[1,1],[1,1]]];return s.default.Set().withMutations((s=>{for(let r=0;r<2;r++)for(let o=0;o<2;o++)n[t][r][o]&&s.add(e.move(new u(r,o)))}))}constructor(t,e){super(t,e,"O",f.makeCells(t,e))}with({state:t,base:e}){return new f(t,e)}}class p extends c{static makeCells(t,e){const n=[[[0,1,1],[1,1,0],[0,0,0]],[[1,0,0],[1,1,0],[0,1,0]],[[0,0,0],[0,1,1],[1,1,0]],[[0,1,0],[0,1,1],[0,0,1]]];return s.default.Set().withMutations((s=>{for(let r=0;r<3;r++)for(let o=0;o<3;o++)n[t][r][o]&&s.add(e.move(new u(r,o)))}))}constructor(t,e){super(t,e,"S",p.makeCells(t,e))}with({state:t,base:e}){return new p(t,e)}}class g extends c{static makeCells(t,e){const n=[[[0,1,0],[1,1,1],[0,0,0]],[[0,1,0],[1,1,0],[0,1,0]],[[0,0,0],[1,1,1],[0,1,0]],[[0,1,0],[0,1,1],[0,1,0]]];return s.default.Set().withMutations((s=>{for(let r=0;r<3;r++)for(let o=0;o<3;o++)n[t][r][o]&&s.add(e.move(new u(r,o)))}))}constructor(t,e){super(t,e,"T",g.makeCells(t,e))}with({state:t,base:e}){return new g(t,e)}}class k extends c{static makeCells(t,e){const n=[[[1,1,0],[0,1,1],[0,0,0]],[[0,1,0],[1,1,0],[1,0,0]],[[0,0,0],[1,1,0],[0,1,1]],[[0,0,1],[0,1,1],[0,1,0]]];return s.default.Set().withMutations((s=>{for(let r=0;r<3;r++)for(let o=0;o<3;o++)n[t][r][o]&&s.add(e.move(new u(r,o)))}))}constructor(t,e){super(t,e,"Z",k.makeCells(t,e))}with({state:t,base:e}){return new k(t,e)}}class b extends l{rows;columns;constructor(t,e){super(s.default.Set().withMutations((s=>{for(let n=0;n<t;n++)for(let t=0;t<e;t++)s.add(new h(n,t))}))),this.rows=t,this.columns=e}}class v{config;static nextPreparedBlocks(t){return t.shuffle([new w(0,new h(0,3)),new d(0,new h(0,3)),new m(0,new h(0,3)),new f(0,new h(0,4)),new p(0,new h(0,3)),new g(0,new h(0,3)),new k(0,new h(0,3))])}constructor(t,e){this.config=t,this.state=e instanceof a?{board:new b(t.rows,t.columns),random:e.next(),heldBlock:null,remainingCells:new l,tag:"PrepareNext",blockQueue:v.nextPreparedBlocks(e),currentBlock:null}:e,console.log(this.state)}state;getBlockQueue(){const[t,e,s,n,r,o,i,...a]=this.state.blockQueue;return[t,e,s,n,r,o,i]}newOperateResultNoChange(){return{tag:"Ok",changed:!1,tetris:this}}newOperateResult(t){return{tag:"Ok",changed:!0,tetris:new v(this.config,t)}}newDownBlockResult(t){return{tag:"Ok",tetris:new v(this.config,t)}}newNextBlockResult(t,e){return{tag:"Ok",removedLines:e,tetris:new v(this.config,t)}}newTetrisError(t){return{tag:"Err",message:t}}blocksAreAcceptable(t,e,s){return t.remove(e).isEmpty()&&s.remove(e).isEmpty()&&t.intersect(s).isEmpty()}operateRotate(t){console.log(`operateRotate(clockwise:${t})`);const{tag:e,currentBlock:s,board:n,remainingCells:r}=this.state;"WaitDown"!==e&&o("operateRotate method must be called in WaitDown state");const i=s?.rotate(t);return null!=i&&this.blocksAreAcceptable(i,n,r)?this.newOperateResult({...this.state,currentBlock:i}):this.newOperateResultNoChange()}operateMove(t){console.log(`operateMove(toRight:${t})`);const{tag:e,currentBlock:s,board:n,remainingCells:r}=this.state;"WaitDown"!==e&&o("operateMove method must be called in WaitDown state");const i=s?.move(t?u.right():u.left());return null!=i&&this.blocksAreAcceptable(i,n,r)?this.newOperateResult({...this.state,currentBlock:i}):this.newOperateResultNoChange()}getGhost(){const{tag:t,currentBlock:e,board:s,remainingCells:n}=this.state;let r=e;if(null==r)return null;let o=r.move(u.down());for(;;){if(!this.blocksAreAcceptable(o,s,n))return r;r=o,o=r.move(u.down())}}operateDrop(){console.log("operateDrop");const{tag:t,currentBlock:e}=this.state;"WaitDown"!==t&&o("operateDrop method must be called in WaitDown state");const s=this.getGhost();return null==s||s.equals(e)?this.newOperateResultNoChange():this.newOperateResult({...this.state,currentBlock:s})}operateHold(){console.log("operateHold"),o("operateHold method is not implemented")}downBlock(){console.log("downBlock");const{tag:t,currentBlock:e,board:s,remainingCells:n}=this.state;"WaitDown"!==t&&o("downBlock method must be called in WaitDown state");let r=e?.move(u.down());return null!=r&&this.blocksAreAcceptable(r,s,n)?this.newDownBlockResult({...this.state,currentBlock:r}):this.newDownBlockResult({...this.state,tag:"PrepareNext",currentBlock:null,remainingCells:n.union(e)})}getRemovedLines(){const{currentBlock:t,remainingCells:e}=this.state;let n=e.union(t??new l);const r=new Map;for(let t=0;t<this.config.rows;t++){const e=s.default.Set().withMutations((e=>{for(let s=0;s<this.config.columns;s++){const r=new h(t,s);n.has(r)&&e.add(r)}}));e.size===this.config.columns&&r.set(t,new l(e))}return r}removeLines(){const{currentBlock:t,remainingCells:e}=this.state,s=this.getRemovedLines();let n=e.union(t??new l);for(let t=0;t<this.config.rows;t++){if(!s.has(t))continue;const e=n.toArray().filter((e=>e.row<t)).map((t=>t.move(u.down()))),r=n.toArray().filter((e=>e.row>t));n=new l(r).union(new l(e))}return[s,n]}prepareBlockQueue(){const{blockQueue:t,random:e}=this.state;let[s,...n]=t;return n.length<7&&n.push(...v.nextPreparedBlocks(e)),[s,n]}nextBlock(){const{tag:t,board:e,random:s}=this.state;if(console.log("nextBlock",t),"PrepareNext"!==t)return this.newTetrisError("nextBlock method must be called in PrepareNext state");const[n,r]=this.removeLines(),[o,i]=this.prepareBlockQueue();return this.blocksAreAcceptable(o,e,r)?this.newNextBlockResult({...this.state,tag:"WaitDown",currentBlock:o,blockQueue:i,remainingCells:r,random:s.next()},n):this.newNextBlockResult({...this.state,currentBlock:o,tag:"GameOver"},n)}}function C(t,{cells:e},s){e.forEach((e=>{!function({context:t,cellSize:e,originX:s,originY:n},{col:r,row:o},{padding:i=0,boarder:a=1,fillColor:l,strokeColor:c}){null!=l&&(t.fillStyle=l,t.fillRect(r*e+s+i,o*e+n+i,e-2*i,e-2*i)),null!=c&&(t.strokeStyle=c,t.lineWidth=a,t.strokeRect(r*e+s+i-.5*a,o*e+n+i-.5*a,e-2*i+a,e-2*i+a))}(t,e,s)}))}class B{prevDownTime;downTimeSpan;tetris=function(t,e){return new v(t,e)}({columns:10,rows:20},new a(1));canvas;constructor(t,e){this.prevDownTime=t,this.downTimeSpan=e;const s=$("#main-canvas")[0].getContext("2d");this.canvas={cellSize:20,context:s,height:480,width:640,originX:20,originY:20}}update(t,e){if("WaitDown"===this.tetris.state.tag){const s=this;function n(t,n){if(e.key.down(t)){const t=n();t.changed&&(s.tetris=t.tetris)}}n("KeyA",(()=>this.tetris.operateRotate(!1))),n("KeyD",(()=>this.tetris.operateRotate(!0))),n("ArrowLeft",(()=>this.tetris.operateMove(!1))),n("ArrowRight",(()=>this.tetris.operateMove(!0))),n("ArrowDown",(()=>this.tetris.operateDrop()))}if(t-this.prevDownTime>this.downTimeSpan)switch(this.prevDownTime=t,this.tetris.state.tag){case"PrepareNext":{const r=this.tetris.nextBlock();"Err"===r.tag?console.log(r.message):this.tetris=r.tetris;break}case"WaitDown":{const o=this.tetris.downBlock();"Err"===o.tag?console.log(o.message):this.tetris=o.tetris;break}}return this}draw(){!function({context:t,originX:e,originY:s,width:n,height:r}){t.clearRect(e,s,n,r)}(this.canvas);const{board:t,currentBlock:e,remainingCells:s,tag:n}=this.tetris.state;!function(t,e){C(t,e,{boarder:1,strokeColor:"black"})}(this.canvas,t),C(this.canvas,s,{fillColor:"black",padding:1}),function(t,e){t.context.translate(250,0);for(let s=0;s<Math.min(7,e.length);s++)C(t,e[s],{padding:1,fillColor:"black"}),t.context.translate(0,50);t.context.translate(-250,-350)}(this.canvas,this.tetris.getBlockQueue());for(const[t,e]of this.tetris.getRemovedLines())C(this.canvas,e,{fillColor:"red",padding:1});if("WaitDown"===n){const t=this.tetris.getGhost();C(this.canvas,t,{fillColor:"gray",padding:1})}null!=e&&C(this.canvas,e,{fillColor:"orange",padding:1})}}$((()=>{console.log("load"),new r(new B(0,1)).start()}))}));