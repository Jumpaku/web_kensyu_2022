!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(require("immutable")):"function"==typeof define&&define.amd?define(["immutable"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).Immutable)}(this,(function(t){"use strict";function e(t){return t&&"object"==typeof t&&"default"in t?t:{default:t}}var s=e(t);class n{constructor(){$(window).on("keydown",(t=>{const e=this._down.get(t.code)??0;this._down.set(t.code,e+1)})),$(window).on("keyup",(t=>{const e=this._up.get(t.code)??0;this._up.set(t.code,e+1)}))}_down=new Map;_up=new Map;reset(){this._down=new Map,this._up=new Map}down(t){return this._down.get(t)??0}up(t){return this._up.get(t)??0}}class r{constructor(t){this.performFrame=this.performFrame.bind(this),this.currentScene=t,this.input={key:new n}}currentScene;input;start(){window.requestAnimationFrame(this.performFrame)}performFrame(t){const e=t/1e3;this.currentScene=this.currentScene.update(e,this.input),this.currentScene.draw(),this.input.key.reset(),window.requestAnimationFrame(this.performFrame)}}function o(t){throw new Error(t)}const i=window.Chance;class l{seed;constructor(t){this.seed=t}shuffle(t){const e=[...t];return new i(this.seed).shuffle(e)}next(){let t=new i(this.seed);return new l(t.integer()+t.integer())}}function a(t){return null==t?a(s.default.Set()):new class{cells;constructor(t){this.cells=t}union(t){return a(this.cells.union(t.cells))}intersect(t){return a(this.cells.intersect(t.cells))}remove(t){return a(this.cells.subtract(t.cells))}isEmpty(){return this.cells.isEmpty()}}(t)}class c{state;base;name;cells;constructor(t,e,s,n){this.state=t,this.base=e,this.name=s,this.cells=n}equals(t){return t instanceof c&&this.name===t.name&&this.state===t.state&&s.default.is(this.base,t.base)&&this.cells.equals(t.cells)}hashCode(){return s.default.hash(this)}union(t){return a(this.cells.union(t.cells))}intersect(t){return a(this.cells.intersect(t.cells))}remove(t){return a(this.cells.subtract(t.cells))}isEmpty(){return this.cells.isEmpty()}rotate(t){return t?this.with({state:(this.state+3)%4,base:this.base}):this.with({state:(this.state+1)%4,base:this.base})}move(t){return this.with({state:this.state,base:this.base.move(t)})}}class u{rowDelta;colDelta;static up(){return new u(-1,0)}static down(){return new u(1,0)}static right(){return new u(0,1)}static left(){return new u(0,-1)}constructor(t,e){if(this.rowDelta=t,this.colDelta=e,!(this instanceof u))return new u(t,e)}equals(t){return t instanceof u&&this.rowDelta===t.rowDelta&&this.colDelta===t.colDelta}hashCode(){return s.default.hash(this.rowDelta)-s.default.hash(this.colDelta)}move(t){return t.move(this)}}class h{row;col;constructor(t,e){if(this.row=t,this.col=e,!(this instanceof h))return new h(t,e)}equals(t){return t instanceof h&&this.row===t.row&&this.col===t.col}hashCode(){return s.default.hash(this.row)-s.default.hash(this.col)}move(t){return new h(this.row+t.rowDelta,this.col+t.colDelta)}diff(t){return new u(this.row-t.row,this.col-t.col)}}class w extends c{static makeCells(t,e){const n=[[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],[[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]],[[0,0,0,0],[0,0,0,0],[1,1,1,1],[0,0,0,0]],[[0,0,1,0],[0,0,1,0],[0,0,1,0],[0,0,1,0]]];return s.default.Set().withMutations((s=>{for(let r=0;r<4;r++)for(let o=0;o<4;o++)n[t][r][o]&&s.add(e.move(new u(r,o)))}))}constructor(t,e){super(t,e,"I",w.makeCells(t,e))}with({state:t,base:e}){return new w(t,e)}}class d extends c{static makeCells(t,e){const n=[[[1,0,0],[1,1,1],[0,0,0]],[[0,1,0],[0,1,0],[1,1,0]],[[0,0,0],[1,1,1],[0,0,1]],[[0,1,1],[0,1,0],[0,1,0]]];return s.default.Set().withMutations((s=>{for(let r=0;r<3;r++)for(let o=0;o<3;o++)n[t][r][o]&&s.add(e.move(new u(r,o)))}))}constructor(t,e){super(t,e,"J",d.makeCells(t,e))}with({state:t,base:e}){return new d(t,e)}}class m extends c{static makeCells(t,e){const n=[[[0,0,1],[1,1,1],[0,0,0]],[[1,1,0],[0,1,0],[0,1,0]],[[0,0,0],[1,1,1],[1,0,0]],[[0,1,0],[0,1,0],[0,1,1]]];return s.default.Set().withMutations((s=>{for(let r=0;r<3;r++)for(let o=0;o<3;o++)n[t][r][o]&&s.add(e.move(new u(r,o)))}))}constructor(t,e){super(t,e,"L",m.makeCells(t,e))}with({state:t,base:e}){return new m(t,e)}}class f extends c{static makeCells(t,e){const n=[[[1,1],[1,1]],[[1,1],[1,1]],[[1,1],[1,1]],[[1,1],[1,1]]];return s.default.Set().withMutations((s=>{for(let r=0;r<2;r++)for(let o=0;o<2;o++)n[t][r][o]&&s.add(e.move(new u(r,o)))}))}constructor(t,e){super(t,e,"O",f.makeCells(t,e))}with({state:t,base:e}){return new f(t,e)}}class p extends c{static makeCells(t,e){const n=[[[0,1,1],[1,1,0],[0,0,0]],[[1,0,0],[1,1,0],[0,1,0]],[[0,0,0],[0,1,1],[1,1,0]],[[0,1,0],[0,1,1],[0,0,1]]];return s.default.Set().withMutations((s=>{for(let r=0;r<3;r++)for(let o=0;o<3;o++)n[t][r][o]&&s.add(e.move(new u(r,o)))}))}constructor(t,e){super(t,e,"S",p.makeCells(t,e))}with({state:t,base:e}){return new p(t,e)}}class g extends c{static makeCells(t,e){const n=[[[0,1,0],[1,1,1],[0,0,0]],[[0,1,0],[1,1,0],[0,1,0]],[[0,0,0],[1,1,1],[0,1,0]],[[0,1,0],[0,1,1],[0,1,0]]];return s.default.Set().withMutations((s=>{for(let r=0;r<3;r++)for(let o=0;o<3;o++)n[t][r][o]&&s.add(e.move(new u(r,o)))}))}constructor(t,e){super(t,e,"T",g.makeCells(t,e))}with({state:t,base:e}){return new g(t,e)}}class k extends c{static makeCells(t,e){const n=[[[1,1,0],[0,1,1],[0,0,0]],[[0,1,0],[1,1,0],[1,0,0]],[[0,0,0],[1,1,0],[0,1,1]],[[0,0,1],[0,1,1],[0,1,0]]];return s.default.Set().withMutations((s=>{for(let r=0;r<3;r++)for(let o=0;o<3;o++)n[t][r][o]&&s.add(e.move(new u(r,o)))}))}constructor(t,e){super(t,e,"Z",k.makeCells(t,e))}with({state:t,base:e}){return new k(t,e)}}class b{rows;columns;constructor(t,e){this.rows=t,this.columns=e,this.cells=s.default.Set().withMutations((s=>{for(let n=0;n<t;n++)for(let t=0;t<e;t++)s.add(new h(n,t))}))}cells;union(t){return a(this.cells.union(t.cells))}intersect(t){return a(this.cells.intersect(t.cells))}remove(t){return a(this.cells.subtract(t.cells))}isEmpty(){return this.cells.isEmpty()}}class C{config;static nextPreparedBlocks(t){return t.shuffle([new w(0,new h(0,3)),new d(0,new h(0,3)),new m(0,new h(0,3)),new f(0,new h(0,4)),new p(0,new h(0,3)),new g(0,new h(0,3)),new k(0,new h(0,3))])}constructor(t,e){this.config=t,this.state=e instanceof l?{board:new b(t.rows,t.columns),random:e.next(),heldBlock:null,remainingCells:a(),tag:"PrepareNext",blockQueue:C.nextPreparedBlocks(e),currentBlock:null}:e,console.log(this.state)}state;newOperateResultNoChange(){return{tag:"Ok",changed:!1,tetris:this}}newOperateResult(t){return{tag:"Ok",changed:!0,tetris:new C(this.config,t)}}newDownBlockResult(t){return{tag:"Ok",tetris:new C(this.config,t)}}newNextBlockResult(t,e){return{tag:"Ok",removedLines:e,tetris:new C(this.config,t)}}newTetrisError(t){return{tag:"Err",message:t}}blocksAreAcceptable(t,e,s){return t.remove(e).isEmpty()&&s.remove(e).isEmpty()&&t.intersect(s).isEmpty()}operateRotate(t){console.log(`operateRotate(clockwise:${t})`);const{tag:e,currentBlock:s,board:n,remainingCells:r}=this.state;"WaitDown"!==e&&o("operateRotate method must be called in WaitDown state");const i=s?.rotate(t);return null!=i&&this.blocksAreAcceptable(i,n,r)?this.newOperateResult({...this.state,currentBlock:i}):this.newOperateResultNoChange()}operateMove(t){console.log(`operateMove(toRight:${t})`);const{tag:e,currentBlock:s,board:n,remainingCells:r}=this.state;"WaitDown"!==e&&o("operateMove method must be called in WaitDown state");const i=s?.move(t?u.right():u.left());return null!=i&&this.blocksAreAcceptable(i,n,r)?this.newOperateResult({...this.state,currentBlock:i}):this.newOperateResultNoChange()}getGhost(){const{tag:t,currentBlock:e,board:s,remainingCells:n}=this.state;let r=e;if(null==r)return null;let o=r.move(u.down());for(;;){if(!this.blocksAreAcceptable(o,s,n))return r;r=o,o=r.move(u.down())}}operateDrop(){console.log("operateDrop");const{tag:t,currentBlock:e}=this.state;"WaitDown"!==t&&o("operateDrop method must be called in WaitDown state");const s=this.getGhost();return null==s||s.equals(e)?this.newOperateResultNoChange():this.newOperateResult({...this.state,currentBlock:s})}operateHold(){console.log("operateHold"),o("operateHold method is not implemented")}downBlock(){console.log("downBlock");const{tag:t,currentBlock:e,board:s,remainingCells:n}=this.state;"WaitDown"!==t&&o("downBlock method must be called in WaitDown state");let r=e?.move(u.down());return null!=r&&this.blocksAreAcceptable(r,s,n)?this.newDownBlockResult({...this.state,currentBlock:r}):this.newDownBlockResult({...this.state,tag:"PrepareNext",currentBlock:null,remainingCells:n.union(e)})}getRemovedLines(){const{currentBlock:t,remainingCells:e}=this.state;let n=e.union(t??a()).cells;const r=new Map;for(let t=0;t<this.config.rows;t++){const e=s.default.Set().withMutations((e=>{for(let s=0;s<this.config.columns;s++){const r=new h(t,s);n.has(r)&&e.add(r)}}));e.size===this.config.columns&&r.set(t,a(e))}return r}removeLines(){const{currentBlock:t,remainingCells:e}=this.state,s=this.getRemovedLines();let n=e.union(t??a()).cells;for(let t=0;t<this.config.rows;t++){if(!s.has(t))continue;const e=n.filter((e=>e.row<t)).map((t=>t.move(u.down()))),r=n.filter((e=>e.row>t));n=r.union(e)}return[s,a(n)]}prepareBlockQueue(){const{blockQueue:t,random:e}=this.state;let[s,...n]=t;return n.length<7&&n.push(...C.nextPreparedBlocks(e)),[s,n]}nextBlock(){const{tag:t,board:e,random:s}=this.state;if(console.log("nextBlock",t),"PrepareNext"!==t)return this.newTetrisError("nextBlock method must be called in PrepareNext state");const[n,r]=this.removeLines(),[o,i]=this.prepareBlockQueue();return this.blocksAreAcceptable(o,e,r)?this.newNextBlockResult({...this.state,tag:"WaitDown",currentBlock:o,blockQueue:i,remainingCells:r,random:s.next()},n):this.newNextBlockResult({...this.state,currentBlock:o,tag:"GameOver"},n)}}class B{tetris=function(t,e){return new C(t,e)}({columns:10,rows:20},new l(1));constructor(){}update(t,e){if("WaitDown"===this.tetris.state.tag){const s=this;function n(t,n){if(e.key.down(t)){const t=n();t.changed&&(s.tetris=t.tetris)}}n("KeyA",(()=>this.tetris.operateRotate(!1))),n("KeyD",(()=>this.tetris.operateRotate(!0))),n("ArrowLeft",(()=>this.tetris.operateMove(!1))),n("ArrowRight",(()=>this.tetris.operateMove(!0))),n("ArrowDown",(()=>this.tetris.operateDrop())),n("ArrowUp",(()=>this.tetris.operateHold()))}if(e.key.down("Space"))switch(this.tetris.state.tag){case"PrepareNext":{const r=this.tetris.nextBlock();"Err"===r.tag?console.log(r.message):this.tetris=r.tetris;break}case"WaitDown":{const o=this.tetris.downBlock();"Err"===o.tag?console.log(o.message):this.tetris=o.tetris;break}}return this}draw(){const t={cellSize:20,context:$("#main-canvas")[0].getContext("2d"),height:480,width:640,originX:20,originY:20};!function({context:t,originX:e,originY:s,width:n,height:r}){t.clearRect(e,s,n,r)}(t),function(t,e){const{context:s,cellSize:n}=t;s.strokeStyle="blue",s.lineWidth=1,s.strokeRect(n-1,n-1,n*e.columns+2,n*e.rows+2)}(t,this.tetris.state.board),v(t,this.tetris.state.remainingCells,{fillColor:"black",padding:1});for(const[e,s]of this.tetris.getRemovedLines())v(t,s,{fillColor:"red",padding:1});const e=this.tetris.getGhost();null!=e&&"WaitDown"===this.tetris.state.tag&&v(t,e,{fillColor:"gray",padding:1}),null!=this.tetris.state.currentBlock&&v(t,this.tetris.state.currentBlock,{fillColor:"orange",padding:1})}}function v(t,{cells:e},s){e.forEach((e=>{!function({context:t,cellSize:e,originX:s,originY:n},{col:r,row:o},{padding:i=0,boarder:l=1,fillColor:a,strokeColor:c}){null!=a&&(t.fillStyle=a,t.fillRect(r*e+s+i,o*e+n+i,e-2*i,e-2*i)),null!=c&&(t.strokeStyle=c,t.lineWidth=l,t.strokeRect(r*e+s+i-.5*l,o*e+n+i-.5*l,e-2*i+l,e-2*i+l))}(t,e,s)}))}$((()=>{console.log("load"),new r(new B).start()}))}));